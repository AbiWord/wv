<title>firewalls.9512: How Windows encrypts .PWL files (fwd)</title>
<TITLE>NETSYS.COM</TITLE>
<META NAME="DESCRIPTION" CONTENT="NETSYS.COM Solaris Test Facility">
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000FF" ALINK="#FF0000">
<CENTER>
<P><A NAME="top.html"><IMG SRC="/gifs/header.gif" ALT="len@netsys.com"></a>
<BR>
<B>NETSYS.COM:</B>
<A HREF="http://www.netsys.com/services.html">Unix System Administration</a> | <A HREF="http://www.netsys.com/archives.html">Mailing List Archives</a> | <A HREF="http://www.netsys.com/video.html">Realtime Video Server</a> | <A HREF="http://www.netsys.com/cgi-bin/bbc_man2html">Solaris 2.5.1 Manuals</a> | <a href="http://www.netsys.com/network.html">SNMP Monitoring</a> | <a href="http://www.netsys.com/resume.html">Resume</a> | <a href="mailto: len@netsys.com">Send Mail</a> |<A HREF="http://www.netsys.com/site.html">Site Map</a> | <A HREF="http://www.netsys.com/index.html">Home</a>
<p>
<IMG SRC="/gifs/bbar.gif" align="bottom"  ALT="----------------"></CENTER>
<H3><FONT COLOR="#000000">

<FONT SIZE=2>
</FONT>
<!-- received="Wed Dec 13 12:46:19 1995 PST" -->
<!-- sent="Wed, 13 Dec 1995 14:41:34 -0500 (EST)" -->
<!-- name="Brain21" -->
<!-- email="brain21@montag33.residence.gatech.edu" -->
<!-- subject="How Windows encrypts .PWL files (fwd)" -->
<!-- id="199512131909.LAA13755@desiree.teleport.com" -->
<!-- inreplyto="" -->
<title>firewalls.9512: How Windows encrypts .PWL files (fwd)</title>
<h1>How Windows encrypts .PWL files (fwd)</h1>
Brain21 (<i>brain21@montag33.residence.gatech.edu</i>)<br>
<i>Wed, 13 Dec 1995 14:41:34 -0500 (EST)</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#442">[ date ]</a><a href="index.html#442">[ thread ]</a><a href="subject.html#442">[ subject ]</a><a href="author.html#442">[ author ]</a>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="0443.html">Brain21: "Internet Hacking isn't just for Unix kiddiez anymore (fwd)"</a>
<li> <b>Previous message:</b> <a href="0441.html">Randal L. Schwartz: "replying to apparently false accusations by my former co-worker Jeff Sadayao"</a>
<!-- nextthread="start" -->
</ul>
<!-- body="start" -->
Well, everyone has been talking about this, so I figured I would forward <br>
this along.  If this has already been circulated, a NICE note would be <br>
appreciated, and not flames.<br>
<p>
Thanks,<br>
<p>
Brain21<br>
<p>
---------- Forwarded message ----------<br>
Date: 28 Nov 1995 13:13:36 GMT<br>
From: Peter Gutmann &lt;pgut01@cs.auckland.ac.nz&gt;<br>
Subject: How Windows encrypts .PWL files<br>
<p>
<p>
<p>
Windows for Workgroups can assign passwords to shared resources such as shared<br>
directories, printer queues, and network DDE shares.  To save having to enter a<br>
password for each resource each time you log on, it keeps encrypted copies of<br>
the passwords in password (.PWL) files and decrypts them with the password you<br>
use initially to log on.  The details of this are mostly undocumented "for<br>
security reasons".  They're about to become documented...<br>
 <br>
When you log on for the first time or when you delete your .PWL file, Windows<br>
will ask you whether you want it to create a password file for you.  This<br>
contains the encrypted passwords.  You add passwords to the file using the<br>
semi-documented WNetCachePassword() function and retrieve them using the<br>
equally semi-documented WNetGetCachedPassword() function.  Anything running on<br>
the machine at any time a user is logged on can use WNgetGetCachedPassword() to<br>
retrieve any of the passwords in the .PWL file.  When you add a password, you<br>
supply the name of the resource it pertains to (eg "\\NTSERVER\PRINTER1"), the<br>
password itself, and a number from 1 to 254 for the resource type (more about 0<br>
and 255 later). Windows reserves resource types 1, 2, and 3 for its own use for<br>
network resources.  The .PWL file is not protected from modification.  To use a<br>
new password to access the network, simply delete the .PWL file and Windows<br>
will ask you if you want to create a new one the next time you log on.<br>
 <br>
There can be no more than 255 passwords with types 1 to 127.  If more than 256<br>
are added, Windows starts throwing existing ones away to make room.  You can<br>
avoid this by giving the resource a type from 128 to 254, but once you've used<br>
up this range all further attempts to add passwords will fail.  By adding too<br>
many passwords of either type, you can either cause all existing passwords to<br>
be discarded by Windows or saturate the password file so no new passwords can<br>
be added.  Most users (if they can figure out what's going wrong) will respond<br>
by deleting the password file and starting again with a new file, giving you a<br>
chance to recover from any "mistakes" you may have made with their .PWL file.<br>
 <br>
The .PWL file contains a small header, two blocks of 256 byte-fields, and then<br>
the encrypted password resources.  The header consists of a 4-byte magic ID<br>
"\xB0MFN", a 4-byte count of the number of password resources, 256 fields<br>
containing resource numbers or 0 if this resource is unused (which is why<br>
resource type 0 isn't allowed), and 256 fields containing a resource key or<br>
0xFF is this field is unused (which is why resource type 255 isn't allowed).<br>
When you add a new password resource, Windows scans through the second array<br>
looking for the first 0xFF entry and then uses this to store the password<br>
information.<br>
 <br>
Following this data come the encrypted password resources.  Windows stores the<br>
logon password in memory at all times, performing a simple transformation on a<br>
copy of it whenever it's needed to encrypt or decrypt resources.  The password<br>
is copied around to other memory locations as needed.  Since the original<br>
password location isn't in a VxD (Windows virtual device driver), it can be<br>
swapped to disk at any point, and given that it's in memory for the whole time<br>
Windows is in use but is only rarely used, it probably does end up in the<br>
swapfile on numerous occasions.<br>
 <br>
The transformation performed on the in-memory password, which reduces a<br>
variable-length password to 32 bits, is as follows:<br>
 <br>
    unsigned long result = 0L;<br>
 <br>
    for( i = 0; i &lt; passwordLen + 1; i++ )<br>
        {<br>
        int tmp = ( int ) ( result &gt;&gt; 25 );<br>
 <br>
        result += toupper( password[ i ] );<br>
        result = ( result &lt;&lt; 7 ) | tmp;<br>
        }<br>
 <br>
Note the use of passwordLen + 1, which includes the null terminator at the end<br>
of the string as part of the password.  The effect is simply to rotate the<br>
final result by 7 bits as toupper( password[ i ] ) == 0.  Here's the output<br>
from the password "blem":<br>
 <br>
           After     After <br>
            add     rotate<br>
 <br>
    i = 0 00000042 00002100<br>
    i = 1 0000214C 0010A600<br>
    i = 2 0010A645 08532280<br>
    i = 3 085322CD 29916684<br>
    i = 4 29916684 C8B34214<br>
 <br>
This 32-bit key is then passed to RC4 which is used to encrypt or decrypt the<br>
resources.  The above key would be passed to RC4 as { 0x14, 0x42, 0xB3, 0xC8 }.<br>
The RC4 implementation was licensed by MS in object form and probably comes<br>
from the BSAFE toolkit.  I assume everyone has seen RC4 so I won't include it<br>
here (in any case the implementation used in Windows is fairly grotty, I'd<br>
recommend using the asm version I posted to sci.crypt a few weeks ago).<br>
 <br>
The RC4 key usually doesn't contain anywhere near 32 bits of entropy, although<br>
as a whole it's not spectacularly ugly (you just keep rotating the 32-bit<br>
value, adding in one letter of the password each time).  It's probably easier<br>
to brute-force the 32-bit key than to try anything clever based on the fact<br>
that the password will generally consist entirely of uppercase letters.<br>
 <br>
There have been numerous posts in the past on the insecurity of Windows<br>
networking.  This one shows that even the very basic access control mechanisms<br>
are highly insecure, and what's more can't really be made secure: You can patch<br>
Windows to use the whole logon password instead of the mangled 32-bit version<br>
as the RC4 key, but then you need to contend with the fact that any program can<br>
get a password with WNetGetCachedPassword() at any time (think of the<br>
possibilities with a machine running arbitrary apps and a live internet<br>
connection to send the results over) and that the original password is sitting<br>
in memory (and in the swapfile) most of the time.<br>
 <br>
In conclusion: The Windows password/.PWL encryption is quite weak and should<br>
not be relied upon to keep any information secure, or to secure access to<br>
sensitive resources.<br>
 <br>
Peter.<br>
<!-- body="end" -->
<p>
<ul>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="0443.html">Brain21: "Internet Hacking isn't just for Unix kiddiez anymore (fwd)"</a>
<li> <b>Previous message:</b> <a href="0441.html">Randal L. Schwartz: "replying to apparently false accusations by my former co-worker Jeff Sadayao"</a>
<!-- nextthread="start" -->
</ul>
